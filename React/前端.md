# React18 

笔记基于**黑马**

https://www.bilibili.com/video/BV1ZB4y1Z7o8/?vd_source=8a49335b38d7c23e4806c2d0a1adfb84

React由Meta公司开发，是一个用于 构建Web和原生交互界面的库



# Git

**LF**

全名 Line Feed  ，主要用在unix系统，他将光标向下移动到新行，而不返回到该行的开头，字符表现是 \n

**CRLF**

全名 Carriage Return and Line Feed ， 主要用在 windows和其他非unix的系统，它将光标移动到新行和同一行的开头。字符表现是\r\n

https://juejin.cn/post/7206749400171872315



`git add .` 是 Git 中的一个命令，用于将当前目录及其所有子目录中的所有更改文件添加到暂存区（staging area），以便在下一次执行 `git commit` 时一起提交。暂存区是一个中间区域，用于准备将更改提交到本地 Git 仓库。

**`.`**:当前工作目录及其所有子目录，因此 `git add .` 将会递归地添加所有的更改，包括新增、修改和删除的文件。

`git commit -m "Add your message"`



# F12 查看接口返回数据

![image-20240814024641088](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240814024641088.png)

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240814024522417.png" alt="image-20240814024522417" style="zoom: 50%;" />



# JS基础

1. `${var}` 是一种在 JavaScript 中常见的字符串模板语法（Template Literals），用于在字符串中嵌入变量或表达式。模板字符串使用反引号（\`）包围，并且可以通过 `${}` 语法将变量或表达式插入到字符串中

```js
const name = "Alice";
const age = 30;
const greeting = `Hello, my name is ${name} and I am ${age} years old.`;

console.log(greeting);
// 输出: Hello, my name is Alice and I am 30 years old.

```



# 前端资料

https://mp.weixin.qq.com/s/CT5RFhQv_tcxiojP0gau2A

黑马：https://yun.itheima.com/subject/webmap/index.html

# Day 1

## CRA 核心组件

**create-react-app（CRA）**是一个快速创建React开发环境的工具，底层由Webpack构件，封装了配置细节，开箱即用

执行命令：

```bash
npx create-react-app react-basic
```

> 1. npx -  Node.js工具命令，查找并执行后续的包命令
> 2. create-react-app - 核心包（固定写法），用于创建React项目
> 3. react-basic  React项目的名称（可以自定义）



`index.js`的作用：

- 先将项目的根组件App(见`App.js`)渲染到上面
- 再创建一个id为root的dom节点，渲染到`index.html` <div id="root"></div> 部分

```javascript
//index.js 代码
import { createRoot } from 'react-dom/client'
import App from './App'

const root = createRoot(document.querySelector('#root'))
root.render(<App />)

```



## 启动项目

> cd ...
>
> npm start
>
> npm install
>
> - npm（全称Node Package Manager）是Node.js的官方包管理系统，提供了发布、发现和安装Node.js模块的功能。
> - 当在包含 package.json 文件的项目目录中运行 npm install 时，npm会读取该文件，并根据其中“dependencies”和“devDependencies”字段所列出的模块及其版本要求，自动下载并安装到当前项目的本地 node_modules目录中。



## 项目目录结构

```bash
-src
  -apis           项目接口函数
  -assets         项目资源文件，比如，图片等
  -components     通用组件
  -pages          页面组件
  -store          集中状态管理
  -utils          工具，比如，token、axios 的封装等
  -App.js         根组件
  -index.css      全局样式
  -index.js       项目入口
```





## JSX基础

> 概念：JSX是JavaScript和XMl(HTML)的缩写，表示在JS代码中编写HTML模版结构，它是React中构建UI的方式

```jsx
const message = 'this is message'

function App(){
  return (
    <div>
      <h1>this is title</h1>
      {message}
    </div>
  )
}
```

> 优势：
>
> 1. HTML的声明式模版写法
> 2. JavaScript的可编程能力



> JSX并不是标准的JS语法，它是 JS的语法扩展，浏览器本身不能识别，需要通过解析工具做解析之后才能在浏览器中使用

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240702093126692.png" alt="image-20240702093126692" style="zoom: 33%;" />





## JS表达式—大括号{}

在JSX中可以通过 ==大括号语法{}==识别JavaScript中的表达式，常见的有：

1. 使用引号传递字符串
2. 使用JS变量
3. 函数调用和方法调用
4. 使用JavaScript对象
	

```jsx
const message = 'this is message'

function getAge(){
  return 18
}

function App(){
  return (
    <div>
      <h1>this is title</h1>
      
      {/* 字符串识别 */}
      {'this is str'}
      {/* 变量识别 */}
      {message}
      {/* 函数调用 渲染为函数的返回值 */}
      {getAge()}
    </div>
  )
}
```

==warning==：if语句、switch语句、变量声明不属于表达式，不能出现在{}中





## JSX高频场景-列表渲染`map方法` 

```jsx
const list = [
  {id:1001, name:'Vue'},
  {id:1002, name: 'React'},
  {id:1003, name: 'Angular'}
]

function App(){
  return (
    <ul>
      {list.map(item => <li key={item.id}>{item.name}</li>)}
    </ul>
  )
}
```

> 1. map循环哪个结构
>
> 2. `item =>`：这是一个箭头函数，`item` 是数组中的每个元素(可以替换成其他名字)。这个函数对每个元素返回一个 `<li>` 元素
>
> 3. key的作用：Each child in a list should have a unique "key" prop ---> key={item.id}
>
> 	react框架内部使用，用来提升更新性能

```js
array.map(function(currentValue, index, array) {
  // 逻辑
}, thisArg);
```





## JSX高频场景-条件渲染

**简单条件渲染**

`A && B`  ：如果A为true，则显示B，否则不显示

`三元表达式(A ? B : C) `：如果A为true，则显示B，否则显示C



**复杂条件渲染**

根据多种条件返回不同值：自定义函数 +if 判断语句

> 在 JSX 中，`===` 是 JavaScript 中的严格相等运算符，用于比较两个值是否完全相等。严格相等运算符会比较两个值的类型和值，如果类型和值都相等，则返回 `true`，否则返回 `false`。这与松散相等运算符 `==` 不同，后者在比较时会进行类型转换。





## 事件绑定的多种形式

```javascript
function App () {
  // 基础绑定
  // const handleClick = () => {
  //   console.log('button被点击了')
  // }

  // 在事件回调函数中设置形参e
  // const handleClick = (e) => {
  //   console.log('button被点击了', e)
  // }

  // 传递自定义参数，形参name
  // const handleClick = (name) => {
  //   console.log('button被点击了', name)
  // }

  // 既要传递自定义参数 而且还要事件对象e
  const handleClick = (name, e) => {
    console.log('button被点击了', name, e)
  }
  
  
  return (
    <div className="App">
      /*基础绑定&事件形参e*/
      <button onClick={handleClick}>click me </button>
     /* Attention！！！自定义参数，不能直接写函数调用，这里事件绑定需要一个函数引用，传递实参jack*/
      <button onClick={() => handleClick('jack')}>click me </button>
    </div>
  )
}

export default App

```

### 箭头函数

**箭头函数 (Arrow Function)**：使用 `=>` 符号来定义，如`函数名= (参数) => {函数体}`。

**匿名箭头函数：**`(参数) => {函数体}`。

当箭头函数只有一个参数时可以省略参数外面的括号`参数 => {函数体}`。

**普通函数**：使用 `function` 关键字来定义，如 `function(参数) {函数体}`。

```javascript
// 箭头函数
const arrowFunction = () => console.log('Arrow Function');
arrowFunction();

// 普通函数
function regularFunction() {
  console.log('Regular Function');
}
regularFunction();
```



### 函数调用和函数引用

为了在按钮点击时调用 `handleClick` 并传递参数，我们需要传递一个函数引用。在 React 中，常用的解决方案是使用箭头函数或者 `bind` 方法创建一个新函数，该函数在事件触发时才会执行。

```jsx
/*函数引用，在按钮被点击时才会执行*/
<button onClick={handleClick}>Click me</button>
/*函数调用，在渲染时立即执行，而不是在事件发生时执行*/
<button onClick={handleClick()}>Click me</button>
/*传递带参数的函数引用*/
/*如果你需要在事件处理函数中传递参数，那么你不能直接传递函数引用，因为这会导致立即执行函数。相反，你需要传递一个新的函数（比如使用匿名箭头函数），这个新函数在事件发生时执行，并调用原来的函数，同时传递参数。*/
<button onClick={() => handleClick('jack')}>Click me</button>
```



## 自定义组件

> 在React中，一个组件就是**首字母大写的函数function**，内部存放了组件的逻辑和视图UI, 渲染组件只需要把组件当成标签书写即可

```jsx
// 1. 定义组件
function Button(){
  return <button>click me</button>
}

// 2. 使用组件
function App(){
  return (
    <div>
      {/* 自闭合 */}
      <Button/>
      {/* 成对标签 */}
      <Button></Button>
    </div>
  )
}
```





## 基本Hooks

### **useState**

允许我们向组件添加一个`状态变量`, 从而控制影响组件的渲染结果

和普通JS变量不同的是，状态变量一旦发生变化组件的视图UI也会跟着变化==（数据驱动视图）==

```jsx
function App(){
  /*
  1.useState是一个函数，返回值是一个数组
  2.第一个参数count是状态变量，第二个参数是set函数用来修改状态变量
  3.useState的参数作为count的初始值
  */
  const [ count, setCount ] = React.useState(0)
  return (
    <div>
      <button onClick={()=>setCount(count+1)}>{ count }</button>
    </div>
  )
}
```



> 在React中状态被认为是只读的，我们应该始终`替换它而不是修改它`, 直接修改状态不能引发视图更新

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240702121309746.png" alt="image-20240702121309746" style="zoom: 33%;" />



## 修改对象状态

> 对于对象类型的状态变量，应该始终给set方法一个`全新的对象` 来进行修改
>
> ... form先展开字段

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240702121333177.png" alt="image-20240702121333177" style="zoom:33%;" />



## 组件的样式处理

> React组件基础的样式控制有俩种方式，行内样式和class类名控制

```jsx
/*
外层大括号 {} 表示我们在 JSX 中嵌入一个 JavaScript 表达式，用来识别JS对象
内层大括号 {} 表示一个 JavaScript 对象：{ color:'red'}
*/
<div style={{ color:'red'}}>this is div</div>
```



## 案例

1. 显示评论：维护commentList ——使用useState
2. 删除按钮显示：只能删除自己的评论 ——条件渲染
3. 删除功能: 以当前id作为条件过滤 —— filter() 过滤出不相等的情况

```javascript
commentList.filter(item => item.rpid !== rpid)
```

4. tab切换类交互：

	**使用RTK编写管理** 

	- activeIndex（记录下当前点击项）：放在commentStore中initialState属性下
	- 编写action creator reducer：changeActiveIndex
	- 动态控制激活类名（activeIndex===index）

	```js
	className={classNames(
	              'list-menu-item',
	              activeIndex===index && 'active'
	            )}
	```

	



## 模版字符串

模板字符串 (Template Literals)：模板字符串用反引号（\`）括起来，可以包含==嵌入的表达式==，这些表达式放在 `${}` 中。模板字符串的好处包括==多行字符串、嵌入变量和表达式==。

```jsx
className={`nav-item ${type === item.type && 'active'}`}
```



## 利用classNames优化类名控制

需要安装！！` npm install classnames`

现在的问题：字符串的拼接方式不够直观，也容易出错

静态类名:  `nav-item`

动态类名: `key`表示要控制的类名，value表示条件，true的时候类名显示 

```jsx
 <span className= {classNames('nav-item' ,{active:type === item.type})}
```





## Javascript工具库 Lodash

https://www.lodashjs.com/

> 如何使用：
>
> 1. npm i lodash （安装lodash i-install）
>
> 2. import _ from 'lodash'
> 	Lodash 通常被命名为 `_`，这是一个约定俗成的命名方式，简短且便于使用。



## 排序

利用Lodash 

``` javascript
setCommentList(_.orderBy(commentList,['like'],['desc']))
```





# Day 2

## 表单控制

### 受控绑定—useState()

> 概念：使用React组件的状态（useState）控制表单的状态

![image-20240703115747109](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240703115747109.png)

```jsx
function App(){
  //准备React状态值state
  const [value, setValue] = useState('')
  return (
    <input 
      type="text" 
      //state绑定到input的value属性
      value={value} 
      //把input最新的value值设置给state
      onChange={e => setValue(e.target.value)}
    />
  )
}
```

#### 应用场景

- 表单数据管理
- 组件显示/隐藏控制
- 计数器和其他简单状态管理
- 异步数据加载和状态更新
- 单选按钮组等选择控件的状态管理





### 非受控绑定—useRef()

**概念：通过获取==DOM的方式==获取表单的输入数据**

### DOM概念

> HTML DOM 是：
>
> > - HTML 的标准对象模型
> > - HTML 的标准编程接口
> > - W3C 标准
>
> HTML DOM 定义了所有 HTML 元素的*对象*和*属性*，以及访问它们的*方法*。

```jsx
//1.导入模块useRef
import { useRef } from 'react'

function App(){
  //2.使用useRef创建ref对象,未获得dom元素之前默认为null
  const inputRef = useRef(null)

  //4.渲染完毕后，dom生成才可用，ref.current获取dom
  const onChange = ()=>{
    console.log(inputRef.current.value)
  }
  
  return (
    <input 
      type="text" 
      //3.ref对象与JSX绑定（绑定至dom对象）
      ref={inputRef}
      onChange={onChange}
    />
  )
}
```

 

## id处理和时间处理

```jsx
//生成随机id
npm install uuid
import { v4 as uuidv4 } from 'uuid'
uuidV4()
```

```jsx
npm install dayjs
import dayjs from 'dayjs'
ctime: dayjs(new Date()).format('MM-DD HH:mm')
```



## 评论发布

```jsx
handlePublish = () => {
  setCommentList([
     //展开评论数组
      ...commentList
    {
    //新的评论对象
    }
  ])
  //清空内容 
  setContent('')
  //重新聚焦：需要通过useRef获取评论框dom对象
  inputRef.current.focus()
}
```



## 组件通信

> 概念：组件通信就是`组件之间的数据传递`, 根据组件嵌套关系的不同，有不同的通信手段和方法

![image-20240703153741678](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240703153741678.png)

1. A-B 父子通信
2. B-C 兄弟通信
3. A-E 跨层通信





### **A-B 父子通信**

**父传子**

> 1. 父组件传递数据 - 在子组件标签上绑定属性 
> 2. 子组件接收数据 - 子组件通过props参数接收数据,props对象里面包含了父组件传递过来的所有的数据 
> 	- **props可以传递任意的合法数据**，比如数字、字符串、布尔值、数组、对象、函数、==JSX==,只要绑在子组件后面就行
> 	- props只读
> 	- <Son>   \<span>嵌套标签</span>   </Son>通过props.children获取
>
> ```jsx
> //子组件接收数据 
> function Son(props){
>   return <div>{ props.name },{props.age}</div>
> }
> 
> 
> function App(){
>   const name = 'this is app name'
>   return (
>     <div>
>       //父组件传递数据 - 在子组件标签上绑定属性 
>        <Son name={name}
>          		age={18}
>          //JSX
>          		 
>          />
>     </div>
>   )
> }
> ```



**子传父**

> 在子组件中调用父组件中的函数并传递参数
>
> 1. 父组件给子传函数
> 2. 子组件用将参数传到这个里函数
>
> ```tsx
> /*解构语法：这里使用Son({ onGetMsg })而不是Son(props)*/
> function Son({ onGetMsg }){
>   const sonMsg = 'this is son msg'
>   return (
>     <div>
>       {/* 在子组件中执行父组件传递过来的函数 */}
>       <button onClick={()=>onGetMsg(sonMsg)}>send</button>
>     </div>
>   )
> }
> 
> 
> function App(){
>   const getMsg = (msg)=>console.log(msg)
>   
>   return (
>     <div>
>       {/* 传递父组件中的函数getMsg到子组件,onGetMsg为自定义的名字 */}
>        <Son onGetMsg={ getMsg }/>
>     </div>
>   )
> }
> ```

<figure class="third">
 <div class="image-container" style="display: inline-block; width: 48%;  box-sizing: border-box;">
		<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240703173039970.png" alt="***"  />
     <figcaption style="text-align: center; font-weight: bold;margin-top:10px;">子传父</figcaption>
  </div>
 <div class="image-container" style="display: inline-block; width: 48%; box-sizing: border-box;">
		<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240703173003929.png" alt="***"  />
     <figcaption style="text-align: center;font-weight: bold;margin-top:10px;">父传子</figcaption>
  </div>
</figure>




### **B-C 兄弟通信**

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240703173121095.png" alt="image-20240703173121095" style="zoom:27%;" />

> 实现思路: 借助 `状态提升` 机制，通过共同的父组件进行兄弟之间的数据传递
>
> 1. A组件先通过子传父的方式把数据传递给父组件App
> 2. App拿到数据之后通过父传子的方式再传递给B组件





### **A-E 跨层通信**

> 1. 使用 `createContext`方法创建一个上下文对象Ctx 
> 2. 在顶层组件（App）中通过 `Ctx.Provider` 组件提供数据 
> 3. 在底层组件（B）中通过 `useContext` 钩子函数获取消费数据

![image-20240703174346391](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240703174346391.png)

```jsx
// 1. createContext方法创建一个上下文对象
const MsgContext = createContext()


// 2. 在顶层组件APP 通过Provider组件提供数据 
<MsgContext.Provider value={msg}>
  this is App 
</MsgContext.Provider>


// 3. 在底层组件 通过useContext钩子函数使用数据
const msg = useContext(MsgContext)
```



## 副作用管理-useEffect

> useEffect是一个React Hook函数，用于在React组件中创建不是由事件引起而是由==渲染本身==引起的操作（副作用）, 如发送AJAX请求，更改DOM等等 
>
> 

**场景：**在组件渲染完毕之后，立刻从服务端获取列表数据并显示到页面中，常常应用于发送网络请求

```javascript
useEffect( () => {}, [])
```

- 参数1是一个函数，可以把它叫做==副作用函数==，在函数内部可以放置要执行的操作

- 参数2是一个数组（可选参），在数组里放置==依赖项==，不同依赖项会影响第一个参数函数的执行：

	useEffect副作用函数的执行时机存在多种情况，根据传入依赖项的不同，会有不同的执行表现

	| **依赖项**     | **副作用功函数的执行时机**      |
	| -------------- | ------------------------------- |
	| 没有依赖项     | 组件初始渲染 + 组件更新时执行   |
	| 空数组依赖     | 只在初始渲染时执行一次          |
	| 添加特定依赖项 | 组件初始渲染 + 依赖项变化时执行 |



```javascript
useEffect(() => {
    async function getList () {
      const res = await fetch(URL)
      const jsonRes = await res.json()
      console.log(jsonRes)
    }
    getList()
  }, [])	
```

> - `async` 关键字用于声明一个异步函数。当函数执行时，它会立即返回一个 `Promise`，然后在异步操作完成后，使用 `await` 关键字等待 `Promise` 被解决或被拒绝。
>
> - `Promise` 是一种用于处理异步操作的对象。它表示一个尚未完成但预计在未来某个时间点完成的操作，并提供了一种处理结果（成功或失败）的方法。
> 	- **Pending（待定）**：初始状态，操作尚未完成。
> 	- **Fulfilled（已完成）**：操作成功完成，`Promise` 中持有一个值。
> 	- **Rejected（已拒绝）**：操作失败，`Promise` 中持有一个原因（通常是一个错误对象）。
> - `await` 用于等待一个 `Promise` 完成，并返回其解析值。它只能在 `async` 函数中使用。`await` 会暂停 `async` 函数的执行，直到 `Promise` 被解决（resolved）或被拒绝（rejected），然后继续执行函数并返回 `Promise` 的解析值。如果 `Promise` 被拒绝，`await` 会抛出拒绝的错误。
> - `fetch` 和 `XMLHttpRequest (XHR)` 都是用于在客户端和服务器之间进行网络请求的 API



### 清除副作用

- 位置 : 在副作用函数中加

	`return () => { }`

- 执行时机 : 在组件卸载时自动执行



#### 模拟组件卸载

利用`&&` 进行条件渲染

```javascript
function App () {
  const[show,setShow] = useState(true)
  return (
    <div>
     {show && <Son/>}
     <button onClick={()=>setShow(false)}> Delete Son </button>
    </div>
  )
}
```



#### 计时器

```javascript
 useEffect(() => {
 
    const timer = setInterval(() => {
     console.log('timer')
   }, 1000)

    return () => {
    // 清除副作用(组件卸载时)
    clearInterval(timer)
  }
  
   }, [])
```



## 自定义Hook函数

> 自定义Hook是以 `use打头的函数`，通过自定义Hook函数可以用来`实现逻辑的封装和复用`

1. 声明一个以==use打头==的函数
2. 在函数体内封装可复用的逻辑（只要是可复用的逻辑）
3. 把组件中用到的状态或者回调return出去（以对象或者数组）
4. 在哪个组件中要用到这个逻辑，就执行这个函数，解构出来状态和回调进行使用



## ReactHooks

- 只能在==组件中==或者==其他自定义Hook函数==中调用
- 只能在组件的==顶层调用==，不能嵌套在if、for、其它的函数中



## 案例

### **通过接口获取评论列表**

1. 使用` json-server `工具模拟接口服务，通过 `axios` 发送==接口请求==

	json-server是一个快速以.json文件作为数据源模拟接口服务的工具，axios是一个广泛使用的前端请求库

2. 使用useEffect调用接口获取数据

	传入空数组，只在初始渲染时执行一次副作用函数

	

**` json-server `工具模拟接口服务**

1. 安装 `npm install json-server -D`

	https://github.com/typicode/json-server

> `-D`：开发依赖（devDependencies）是只在开发阶段使用的依赖项，而不是在生产环境中使用的依赖项。通常包括构建工具（Webpack、Babel）、测试库（Jest、Mocha）、开发服务器（json-server）等。
>
> 生产依赖（dependencies）是在应用程序运行时需要的依赖项。

2. 准备`db.json`文件

3. 在`package.json`中配置script

	> 当运行 `npm run serve` 或 `yarn serve` 时，j名字为serve的脚本将会执行。`json-server` 会读取 `db.json` 文件，并在本地的 `3004` 端口上启动一个模拟的 RESTful API 服务器。这个服务器将基于 `db.json` 中的数据提供 API 端点，通常包括对数据的 `GET`、`POST`、`PUT` 和 `DELETE` 操作。

	```json
	"scripts": {
	    "start": "react-scripts start",
	    "build": "react-scripts build",
	    "test": "react-scripts test",
	    "eject": "react-scripts eject",
	    "serve": "json-server db.json --port 3004"
	  },
	```



**`axios`** 接口请求

1. 安装 `npm install axios`
2. const res= await axios.get(`URL`)



静态评论列表 vs. 动态获取评论列表

| 特性         | 静态评论列表              | 动态获取评论列表                      |
| ------------ | ------------------------- | ------------------------------------- |
| **数据来源** | 静态 `list`               | 通过 API 动态获取                     |
| **更新方式** | 无法自动更新              | 通过 `axios` 获取数据后更新           |
| **适用场景** | `list` 是静态的，不会改变 | `list` 是动态的，需要从==服务器==获取 |



### 封装Item组件

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240707143710191.png" alt="image-20240707143710191" style="zoom: 50%;" />



# Day 3

**Redux**

> Redux 是React最常用的集中==状态管理工具==，类似于Vue中的Pinia（Vuex），可以独立于框架运行

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240707144300779.png" alt="image-20240707144300779" style="zoom:45%;" />

**优点：**

1. 独立于组件，==无视组件之间的层级关系==，简化通信问题
2. 单项数据流清晰，易于定位bug
3. 调试工具配套良好，方便调试



**使用步骤：**

1. 定义一个 `reducer` 函数

  >  作用: 根据不同的action对象，返回不同的==新的state==
  >
  >  - 该函数接收两个参数，一个旧的状态previousState和一个Action对象
  >  - 返回一个新的状态newState
  >
  >  state: 管理的数据初始状态，具有的属性在initalState中
  >
  >  action: 是一个包含 `type` 和 `payload` 的对象。在 Redux 中，`action` 是触发状态更新的唯一途径。`type` 描述了动作的类型，而 `payload` 通常包含更新状态所需的数据。action通过**action创建函数（Action Creator）**来创建，Action Creator是一个函数，最终返回一个Action对象。

2. 使用createStore方法传 reducer函数 生成一个`store实例对象`

3. 使用store实例的 `subscribe(listener)`方法 订阅数据的变化（数据一旦变化，可以得到通知）

	> 回调函数可以在每次state发生变化的时候自动执行

4. [View视图] 使用store实例的 `dispatch(action)`方法提交action对象 触发数据变化（告诉reducer你想怎么改数据）

5. 使用store实例的 `getState()`方法 获取最新的状态数据更新到视图中

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240801224109444.png" alt="image-20240801224109444" style="zoom:50%;" />







## Redux实现计数器

1. `reducer`函数

	==!!!==数据不可变：不能在原始数据上做修改，必须返回一个新的对象

```javascript
 function reducer (state = { count: 0 }, action) {
    // 数据不可变：基于原始状态生成一个新的状态
    if (action.type === 'INCREMENT') {
      return { count: state.count + 1 }
    }
    if (action.type === 'DECREMENT') {
      return { count: state.count - 1 }
    }
     //若上述两个条件都不满足
    return state
  }
```

2. 生成 store实例对象

```js
const store = Redux.createStore(reducer)
```

3. 通过store实例的subscribe订阅数据变化

```js
 store.subscribe(() => {
  console.log('state变化了')
 })
```

> 回调函数（Callback Function）是指在一个函数中作为参数传递给另一个函数的函数

4.  `dispatch`方法==提交action对象==

```js
// 4. 通过store实例的dispatch函数提交action更改状态 
  // 增
  const inBtn = document.getElementById('increment')
  inBtn.addEventListener('click', () => {
    store.dispatch({
      type: 'INCREMENT'
    })
  })

  // 减
  const dBtn = document.getElementById('decrement')
  dBtn.addEventListener('click', () => {
    store.dispatch({
      type: 'DECREMENT'
    })
  })
```

5. 在subscribe的回调函数中 使用`getState`方法获取最新的状态数据更新到视图中

```js
 store.subscribe(() => {
  console.log('state变化了', store.getState())
  document.getElementById('count').innerText = store.getState().count
 })
```



## **Redux Middleware**

Redux中常用的中间件

> - redux-thunk：action可以是一个函数，用来发起异步请求。
> - redux-promise：action可以是一个promise对象，用来更优雅的进行异步操作。
> - redux-logger：action就是一个标准的plain object，用来记录action和nextState的。
>
> ![image-20240801224653772](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240801224653772.png)



## Redux与React - 环境准备

> Redux虽然是一个框架无关可以独立运行的插件，但是社区通常还是把它与React绑定在一起使用

**浏览器插件：** Redu DevTools



### 1. 配套工具

> 在React中使用redux，官方要求安装俩个其他插件 - Redux Toolkit 和 react-redux

1. Redux Toolkit (RTK) - 官方推荐编写Redux逻辑的方式，是一套工具的集合集，==简化书写==方式

2. react-redux - 用来链接Redux 和 React组件的==中间件==

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240707170301234.png" alt="image-20240707170301234" style="zoom:33%;" />

### 2. 配置基础环境

1.  使用 CRA 快速创建 React 项目

```bash
npx create-react-app react-redux 
```

2.  安装配套工具

```bash
npm i @reduxjs/toolkit  react-redux 
```

3.  启动项目

```bash
npm run start 
//在package.json 可以简化启动server的步骤（windows并不适用）
"start" : "craco start & npm run server"
```



### 3. store目录结构设计

1. 通常集中状态管理的部分都会创建一个单独的 `store` 目录

2. 应用通常会有很多个==子store模块==，所以创建一个 `modules` 目录，在内部编写业务分类的子store

3. store中的==入口文件`index.js `==的作用是组合modules中所有的子模块，并导出store

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240707171152317.png" alt="image-20240707171152317" style="zoom: 33%;" />



## React-Redux实现计数器

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240707171922994.png" alt="image-20240707171922994" style="zoom:50%;" />

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240801225921919.png" alt="image-20240801225921919" style="zoom: 50%;" />



1. `counterStore.js`配置store子模块

  `createSlice`模块

  A function that accepts an initial state, an object of reducer functions, and a "slice name", and ==automatically generates action creators and action types that correspond to the reducers and state.==

<figure class="third">
 <div class="image-container" style="display: inline-block; width: 48%;  box-sizing: border-box;">
		<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240707210443923.png" alt="***"  />
     <figcaption style="text-align: center; font-weight: bold;margin-top:10px;">redux toolkit (RTK简化书写) </br> counterStore.js</figcaption>
  </div>
 <div class="image-container" style="display: inline-block; width: 48%; box-sizing: border-box;">
		<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240707211227248.png" alt="***"  />
     <figcaption style="text-align: center;font-weight: bold;margin-top:10px;">redux</figcaption>
  </div>
</figure>

2. store目录下的`index.js`组合各store子模块,即combineReducers，再导出store

	`import { configureStore } from '@reduxjs/toolkit'`模块
<div style="text-align: center;">
    <img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240707212858206.png" style="zoom:50%;" />
     <figcaption style="text-align: center;font-weight: bold;margin-top:10px;"> index.js </figcaption>
  </div>

3. 为React注入store （source目录下的`index.js`）

	> react-redux负责把Redux和React 链接 起来，内置 `Provider组件`通过 store 参数把创建好的store实例注入到应用中，链接正式建立

	```jsx
	// 导入store
	import store from './store'
	// 导入store提供组件Provider
	import { Provider } from 'react-redux'
	
	ReactDOM.createRoot(document.getElementById('root')).render(
	  // 提供store数据,绑定
	  <Provider store={store}>
	    <App />
	  </Provider>
	)
	```

	

4. React组件==使用==store中的数据（渲染）

> 在React组件中 (`App.js`) 使用store中的数据，需要用到一个钩子函数 - `useSelector`，它的作用是把store中的数据映射到组件中
>
> `useSelector` 函数
>
> React-Redux 提供的一个钩子，用于在函数组件中访问 Redux 状态。它接收一个`选择器函数`作为参数，并返回 Redux store 中的某个状态值。`useSelector` 会订阅 Redux store，当所选状态发生变化时，它会导致组件重新渲染。
>
> `state => state.counter`
>
> 这是一个选择器函数，`useSelector` 会调用它并将整个 Redux store 的状态作为参数传入。选择器函数返回状态中的某个特定部分。
>
> - **`state`**: 代表 Redux store 中的整个状态树。它是一个对象，包含应用程序的所有状态数据。
> - **`state.counter`**: 选择器函数从 Redux store 中提取出 `counter` 部分的状态。

```js
const { count } = useSelector(state => state.counter)
```



5. React组件==修改store==中的数据

> React组件中修改store中的数据需要借助另外一个hook函数 - `useDispatch`，它的作用是生成提交action对象的dispatch函数

```js
import { increment, decrement} from './store/modules/counterStore'
const dispatch = useDispatch()
//在App组件中加入如下代码：
<button onClick={() => dispatch(decrement())}>-</button>
{count}
<button onClick={() => dispatch(increment())}>+</button>
```



6. 提交action传参

> 在reducers的同步修改方法中添加action对象参数，在调用action Creater生成action对象的时候传递参数，参数会被传递到==action对象的payload属性==上

```js
 addToNum (state, action) {
   	state.count = action.payload
   }
```



## 异步action处理

**实现步骤**

1. 创建store的写法保持不变，配置好同步修改状态的方法

```js
const channelStore = createSlice({
  name: 'channel',
  initialState: {
    channelList: []
  },
  reducers: {
    setChannelList (state, action) {
      state.channelList = action.payload
    }
  }
})
```



2. 单独封装一个函数`fetchChannelList`， 是一个 ==异步action creator==
	在函数内部return一个新函数而不是一个普通的action对象，在新函数中
	2.1 封装异步请求获取数据
	2.2 调用同步action Creater`setChannelList`,传入异步数据`res.data.data.channels`,`setChannelList(res.data.data.channels)`生成一个action对象，对象的payload属性值为res.data.data.channels，并使用dispatch提交

```js
// thunk action creator
const { setChannels } = channelStore.actions

const fetchChannelList = () => {
  return async (dispatch) => {
    const res = await axios.get(url)
    dispatch(setChannelList(res.data.data.channels))
  }
}
```

> async (dispatch)  => {} 中的dispatch形参如何来？
>
> 由redux thunk传入
>
> 

3. 组件中dispatch的写法保持不变

```js
 const { channelList } = useSelector(state => state.channel)
 const dispatch = useDispatch()
  useEffect(() => {
    dispatch(fetchChannelList())
  }, [dispatch])
```



> **Action Creator**`fetchChannellist`：
>
> - 当 `fetchChannellist` 在`useEffect()`中被调用时，它返回一个==函数==（而不是一个普通的 action 对象），即
>
> 	```js
>	 return async (dispatch) => {
> 	    const res = await axios.get(url)
>	    dispatch(setChannelList(res.data.data.channels))
> 	  }
> 	```
> 



> - ==同步action==是一种简单的JavaScript对象。它通过store的dispatch方法同步地发送给==reducer进行处理==。它们的目的是描述应用状态的变化，例如用户点击按钮后更新UI，或者在表单中输入文本时更新数据。
> - ==异步action==  被称为“thunk“。它们允许在Redux中处理异步，例如获取数据，并在数据返回后将其==发送给reducer进行处理==。异步action可以使用异步操作库（如Axios或Fetch）执行网络请求，在操作完成后才会触发相应的同步action来更新状态



**概念辨析：**

**Action对象**: 普通的 JavaScript 对象，描述了发生了什么以及携带的相关数据。每个 action 对象至少有一个 `type` 属性，用于指明 action 的类型，通常还会有其他数据属性（称为 `payload`），它们携带更新状态所需的信息。

**Reducer函数**：Reducer 是一个纯函数，它==接收当前的state和一个 action，并返回一个新的状态==。Reducer 决定了在应用中不同类型的 actions 到达时，状态应该如何变化。当使用 `createSlice` 来创建一个 slice 时， reducer 函数同时也会被用来生成对应的 action creators。这意味着，你定义的每个 reducer 函数都会有一个相应的 action creator 用来生成被 dispatch 的 action 对象。

**Action Creator**: 生成 action 对象的函数。使用Redux Thunk 中间件，允许你编写返回函数（而不是 action 对象）的 action creators。这些返回的函数可以包含异步逻辑，然后在异步操作完成后 dispatch actions。



**Redux Toolkit** 提供了 `createSlice` 函数，它可以在定义 reducers 的同时自动生成相应的 action creators。

> ```javascript
> import { createSlice } from '@reduxjs/toolkit';
> 
> const todosSlice = createSlice({
>   name: 'todos',
>   initialState: [],
>   reducers: {
>     addTodo: (state, action) => {
>       state.push({ text: action.payload, completed: false });
>     }
>   }
> });
> 
> // 自动生成的 action creator
> export const { addTodo } = todosSlice.actions;
> 
> // 自动生成的 reducer
> export default todosSlice.reducer;
> 
> ```
>
> 
>
> 在标准的 Redux 中，你需要分别手动定义 action creators 和 reducers。
>
> ```js
> // Action types
> const ADD_TODO = 'ADD_TODO';
> 
> // Action creator
> function addTodo(text) {
>   return {
>     type: ADD_TODO,
>     payload: text
>   };
> }
> 
> // Reducer
> function todosReducer(state = [], action) {
>   switch (action.type) {
>     case ADD_TODO:
>       return [...state, { text: action.payload, completed: false }];
>     default:
>       return state;
>   }
> }
> ```
>
> 



## **美团案例**

### 添加购物车

1. 使用RTK管理新状态cartList

2. 如果添加过，只更新数量count,没有添加过，直接push进去

	```js
	//reducer
	//find 是 JavaScript 数组的一个方法，它返回数组中满足提供的测试函数的第一个元素的值。如果没有元素通过测试，则返回 undefined。在这个例子中，测试函数是 item => item.id === action.payload.id
	addCart(state, action) {
	            const item = state.cartList.find(item =>
	                                             item.id === action.payload.id)
	            if (item) {
	                item.count++
	            } else {
	                state.cartList.push(action.payload)
	            }
	        }
	```


3. 组件中点击时收集数据提交action添加购物车



### 计算购物车总价

```js
 const { cartList } = useSelector(state => state.foods)
  // 计算总价 
  const totalPrice = cartList.reduce((a, c) => a + c.price * c.count, 0)
```

**Reduce函数**

> ```js
>  // JavaScript的 reduce 方法 是一个用于数组的高阶函数，遍历数组中的每个元素，将其累积为单个值
> array.reduce(callback, initialValue);
> ```
>
> **`array`**: 被遍历的数组。
>
> **`callback`**: 这个回调函数在数组的每个元素上执行。它接受四个参数：
>
> 1. `accumulator`（`a`）：累加器，用于累积数组的最终结果。
> 2. `currentValue`（`c`）：数组中正在处理的当前元素。
> 3. `currentIndex`（可选）：当前元素的索引。
> 4. `array`（可选）：调用 `reduce` 方法的数组本身。
>
> **`initialValue`**: （可选）累加器的初始值。如果提供，`accumulator` 在第一次调用回调函数时会被赋值为该值；如果不提供，`accumulator` 将被赋值为数组中的第一个元素，`currentValue` 将从第二个元素开始。



**购物车内点击加号实现数量递减**

```javascript
decreCount(state,action){
  const intem = state.cartList.find (item => item.id === action.payload.id)
  //限制数量不能小于0
  if (item.count === 0){
    return
  }
  item.count--
}

onMinus={()=>dispatch(decreCount({id:item.id}))}
//优化：某件商品数量为0时应该才购物车中删除
```

**`id: item.id`**：

- `id`：这是对象的键，表示 action payload 中的字段名。
- `item.id`：这是对象的值，表示传递给 `id` 字段的实际数据。通常，`item` 是某个对象，在这里它的 `id` 属性被用作 `id` 字段的值。



**控制显示和隐藏购物车**

- 使用useState声明控制显隐的状态

```javascript
const [visible, setVisible] = usestate(false)
```

- 点击统计区域时，设置状态为true，购物车列表显示

```javascript
//添加visible类名可以显示
<div
className={classNames('cartOverlay',visible && 'visible')}
onClick ={()=> setVisible(true)} 
/>
```

- 点击蒙层区域时，设置状态为false，购物车和蒙层隐藏

```javascript
onClick ={()=> setVisible(false)} 
```





# Day 4

## 创建路由开发环境

[React Router](https://reactrouter.com/en/main/start/overview)

```bash
# 使用CRA创建项目
npx create-react-app react-router-pro

# 安装最新的ReactRouter包
npm i react-router-dom

# 启动项目
npm run start
```



## **目录结构**



<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240719162442396.png" alt="image-20240719162442396" style="zoom:50%;" />



<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240719163809955.png" alt="image-20240719163809955" style="zoom:50%;" />

**1.page文件夹下放页面组件并export**

```javascript
const About = () => {
  return <div>我是关于页</div>
}

export default About
```



**2.router文件夹下的`index.js`** 

import各组件,导出router实例

```javascript
import Login from '../page/Login'
import Article from '../page/Article'
import {createBrowserRouter} from 'react-router-dom';

//1.创建router实例对象(数组)并配置路由对应关系
const BrowserRouter = createBrowserRouter([
  {
    path:'/login',
    element:<Login />
  },
  {
    path:'/article',
    element:<Article />
  }
])


export default router
```



**3.在入口文件`index.js`入口文件注入router**

```javascript
// 1. 导入路由router
import {RouterProvider} from 'react-router-dom';
import router from './router'

//2.路由绑定
root.render(
  <React.StrictMode>
    <RouterProvider router={router}> </RouterProvider>
  </React.StrictMode>
);
```





## 路由导航

概念：多个路由之间的跳转，例如点击一个页面的button可以跳转至另外一个页面

### 声明式导航

通过给组件的`to属性`指定要跳转到路由path，组件会被渲染为浏览器支持的`a链接`

如果需要==传参==直接通过==字符串拼接==的方式拼接参数即可

使用场景：菜单绑定

```javascript
import { Link } from 'react-router-dom'
<Link to="/article">跳转到文章页</Link>
```



### 编程式导航

编程式导航是指通过 `useNavigate` 钩子得到导航方法，然后通过调用方法以命令式的形式进行路由跳转

使用场景：==登录请求完毕==之后跳转就可以选择这种方式，更加灵活，多用于逻辑代码

```javascript
import { useNavigate } from 'react-router-dom'
const navigate = useNavigate()
return(
  <div>
  	<button onClick={()=>navigate('article')}></button>
  </div>
)
```



## 导航传参

- `useSearchParams`传参需要 import{ useSearchParams } from "react-router-dom"

- 形式好看但是多了一个步骤

	1. `useParams`传参需要 import{ useParams } from "react-router-dom"

	2. router文件夹下的`index.js` 创建router实例对象需要加上 `/:id`

		> {
		>
		> ​    path: '/article/:id/:name',
		>
		> ​    element: <Article />
		>
		>   },


![7](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/7.png)



## 嵌套路由配置

在一级路由中又内嵌了其他路由，这种关系就叫做嵌套路由，嵌套至一级路由内的路由又称作二级路由

1. router文件夹下的`index.js` import各组件时使用==children==属性配置路由嵌套关系

```javascript
{
	path: '/',
	element: <Father />
    children:[
        {
           path:'children1' 
           element:<Children1 />
        },
        {
           path:'children2' 
           element:<Children2 />
        },
    ]
},


```

2. 在一级路由 Father组件 下配置二级路由的出口<Outlet />

```javascript
import { Link,Outlet } form "react-router-dom"
const Father=() =>{
    return(
    <div>
       我是一级路由组件Father
       <Link to ='/children1'></Link>
       <Link to ='/children2'></Link>
       <Outlet />
    </div>
    )
}
```



**tips:默认二级路由**

当访问的是一级路由时，默认的二级路由组件可以得到渲染

router文件夹下`index.js`二级路由的位置去掉path，设置index属性为true

```js
{
	path: '/',
	element: <Father />
    children:[
        {
           index:true
           element:<Children1 />
        },
        {
           path:'children2' 
           element:<Children2 />
        },
    ]
},
```



## 404路由

router文件夹下`index.js`

```js
{
	path:'*',
	element:<NotFound / >
}
```



## 两种路由模式

各个主流框架的路由常用的路由模式有俩种，history模式和hash模式, ReactRouter分别由 createBrowerRouter 和 createHashRouter 函数负责创建

| 路由模式 | url表现     | 底层原理                    | 是否需要后端支持 | 创建方式            |
| -------- | ----------- | --------------------------- | ---------------- | ------------------- |
| history  | url/login   | history对象 + pushState事件 | 需要             | createBrowserRouter |
| hash     | url/#/login | 监听hashChange事件          | 不需要           | createHashRouter    |



## 配置别名路径

路径解析配置（webpack），把 @/ 解析为 src/

- 安装craco
	npm i -D @craco/craco

- 项目==根目录==下创建配置文件
	craco.config.js

- 配置文件中添加路径解析配置

	```javascript
	const path= require('path')
	module.exports = {  
	    webpack: {
	        alias: {
	          //解析并返回 src 目录的绝对路径，其中 __dirname 是当前模块的目录名。
	          //所以该配置文件一定要放在根目录下
	            '@':path.resolve(dirname, 'src')
	        },
	    }
	
	```

- 包文件中配置启动和打包命令

	```javascript
	/* "scripts": {
	    "start": "react-scripts start",
	    "build": "react-scripts build",
	    "test": "react-scripts test",
	    "eject": "react-scripts eject"
	  },
	*/
	   // change to craco
	
	"scripts": {
	    "start": "craco start",
	    "build": "craco build",
	    "test": "react-scripts test",
	    "eject": "react-scripts eject"
	  },
	```



## 联想路径配置

路径联想配置（VsCode），VsCode 在输入 @/ 时，自动联想出来对应的 src/下的子级目录

配置步骤：

1. ==根目录==下新增配置文件 - `jsconfig.json`
2. 添加路径提示配置

```json
{
  "compilerOptions":{
    "baseUrl":"./",
    "paths":{
      "@/*":[
        "src/*"
      ]
    }
  }
}
```



## json-server实现Mock

在前后端分类的开发模式下，前端可以在没有实际后端接口的支持下先进行接口数据的模拟，进行正常的业务功能开发

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240731162903301.png" alt="image-20240731162903301" style="zoom: 33%;" />

实现步骤：

1. npm i -D  json-server (json-server 是一个node包，可以在不到 30 秒内获得零编码的完整的Mock服务)

2. 准备一个json文件存放数据

3. 添加启动命令 

	```json
	"server": "json-server ./server/data.json  --port 8888"
	```

4.  访问接口进行测试 



## antD主题定制

[Ant Design of React - Ant Design](https://ant.design/docs/react/introduce-cn)

**全局定制**

```css
:root:root{
  --adm-colo-primary:#a062d4
}
```

**局部定制**

```css
.purple-theme{
  --adm-colo-primary:#a062d4
}
```

**scss & sass**

> `SASS` 是一种预编译的 CSS，支持一些比较高级的语法 (例如嵌套样式) ，CRA接入scss非常简单只需要装一个sass工具

```shell
npm install sass -D
//但是在创建样式文件时后缀是scss？？
```

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240805101117537.png" alt="image-20240805101117537" style="zoom: 50%;" />

## 记账本





# Day 6

## 登录Form

1. 为 Form 组件添加 `validateTrigger` 属性，指定校验触发时机的集合

	- 失焦时校验：onBlur

	- 手机号正则校验：正则表达式（Regular Expression，简称 regex 或 regexp）是一种用于描述和匹配字符串模式的特殊字符串。

		>  `^1[3-9]\d{9}$`：匹配中国大陆的手机号。
		>
		> **普通字符**：如 `a`、`b`、`1` 等，表示自己。
		>
		> **元字符**：具有特殊含义的字符
		>
		> - `\`：用于转义元字符，使其作为普通字符使用。
		> - `^`：匹配字符串的开始。
		> - `$`：匹配字符串的结束。
		> - `[]`：表示字符集，匹配方括号内的任意一个字符。
		> - `{}`：指定前一个字符出现的次数。

		

	- 校验顺序:先校验1，1通过后再校验2

		> rules={[
		>
		> {1},
		>
		> {2}
		>
		> ]}



## 获取表单数据

**实现步骤**

1. 为 Form 组件添加 `onFinish` 属性，该事件会在点击登录按钮时触发
2. 创建 onFinish 函数，通过函数参数 values 拿到表单值
3. ==Form 组件(不是Form.Item)==添加 `initialValues` 属性，来初始化表单值

```jsx
// 点击登录按钮时触发 参数values即是表单输入数据
const onFinish = formValue => {
  console.log(formValue)
}


<Form
  onFinish={ onFinish }
>...</Form>
```



## 封装request

**实现步骤**

[Axios](https://axios-http.com/zh/)

1. 安装 axios 到项目  

2. 创建 `utils/request.js` 文件

3. 创建 axios 实例，配置

	 `baseURL`

	`请求拦截器`：在请求发送之前做拦截，插入一些自定义的配置【参数的处理】

	`响应拦截器` ：在响应返回到客户端之前做拦截，重点处理返回的数据

	post 接口文档

	https://apifox.com/apidoc/shared-fa9274ac-362e-4905-806b-6135df6aa90e/api-31967347

	```js
	import axios from 'axios'
	
	const http = axios.create({
	  baseURL: 'http://geek.itheima.net/v1_0',
	  //如果请求超过这个时间限制，将会自动中止
	  timeout: 5000
	})
	
	// 添加请求拦截器
	http.interceptors.request.use((config)=> {
	    return config
	  }, (error)=> {
	    return Promise.reject(error)
	})
	
	// 添加响应拦截器
	http.interceptors.response.use((response)=> {
	    // 2xx 范围内的状态码都会触发该函数。
	    // 对响应数据做点什么
	    return response.data
	  }, (error)=> {
	    // 超出 2xx 范围的状态码都会触发该函数。
	    // 对响应错误做点什么
	    return Promise.reject(error)
	})
	
	export { http }
	```

	

4. 在 `utils/index.js` (utils中多个工具函数统一在该文件下中转导出)中，统一导出request





## 使用Redux管理token

Token作为一个用户的标识数据，需要在很多个模块中共享，Redux可以方便的解决状态共享问题

> 1. Redux中编写获取Token的异步获取和同步修改
>
> 2. Login组件负责提交action并且把表单数据传递过来



## 实现登录逻辑

> 1. 跳转到首页
>
> 2. 提示用户登录成功

```jsx
import { message } from 'antd'
import useStore from '@/store'
import { fetchLogin } from '@/store/modules/user'
import { useDispatch } from 'react-redux'
import {useNavigate} fromn 'react-router-dom'

const Login = () => {
  const dispatch = useDispatch()
  const navigate = useNavigate()
  //加入async和await的作用是保证dispatch完全走完再进行navigate
  const onFinish = async formValue => {
    await dispatch(fetchLogin(formValue))
    //实现登录跳转页面
    navigate('/')
    message.success('登录成功')
  }
  return (
    <div className="login">
     <!-- 省略... -->
    </div>
  )
}

export default Login
```



## token持久化

> 业务背景: Token数据具有一定的时效时间，通常在几个小时，有效时间内无需重新获取
>
> 现有问题: 而基于Redux的存储方式又是基于内存的，刷新就会丢失
>
> 解决方案: **LocalStorage**实现token持久化
> `localStorage` 是 Web 存储 API 的一部分，用于在浏览器中存储数据。它提供了一种简单的方式在用户的浏览器中以键值对的形式存储数据，并且这些数据在页面刷新或浏览器重启后仍然存在
> 一式两份：redux和LocalStorage中各存一份
>
> F12-> Application -> Local Storage -> token



<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240808133724637.png" alt="image-20240808133724637" style="zoom: 33%;" />

```js
 //1. 保存并存Token —— setItem
 //此时刷新页面redux中token值丢了，但是LocalStorage中的保存下来了
reducers: {
        setToken(state, action) {
            state.token = action.payload;
            localStorage.setItem('token', action.payload);
        }
    }

//2. improve第一步，在初始化token的时候判断 —— getItem
initialState: {
        token:localStorage.getItem('token') || '',
    }

```



## 封装Token

> 对于Token的各类操作在项目多个模块中都有用到，为了共享复用可以封装成工具函数
>
> `utils/token.js`文件下
>
> ```javascript
> // 封装存取方法
> 
> const TOKENKEY = 'token_key'
> 
> function setToken (token) {
>   return localStorage.setItem(TOKENKEY, token)
> }
> 
> function getToken () {
>   return localStorage.getItem(TOKENKEY)
> }
> 
> function clearToken () {
>   return localStorage.removeItem(TOKENKEY)
> }
> 
> export {
>   setToken,
>   getToken,
>   clearToken
> }
> ```

**attention!!!** 

除此之外还需要在`utils` 文件夹下的`index.js`文件中导出,目的是其他模块想用不同工具函数只需import`setToken,getToken} from '@/utils';`，无需在导入时填写更详细的路径



# Day 7

## 请求拦截器注入token

> 业务背景: Token作为==用户的数据标识==，也就是说后端有很多接口都需要通过查看当前请求头信息中是否含有token数据，来决定是否正常返回数据；请求拦截器注入Token之后，所有用到Axios实例的接口请求都自动携带了Token

![image-20240809104836694](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240809104836694.png)



```js
// 添加请求拦截器
// 在请求发送之前 做拦截 插入一些自定义的配置 [参数的处理]
request.interceptors.request.use((config) => {
  // 操作这个config 注入token数据
  // 1. 获取到token
  // 2. 按照后端的格式要求做token拼接
  const token = getToken()
  if (token) {
    //等式左边形式由axios决定，右边由后端规定
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
}, (error) => {
  return Promise.reject(error)
})
```

> - **`config.headers`**: 这是一个对象，通常表示 HTTP 请求的配置，`headers` 属性包含了所有的请求头信息。
> - **`Authorization`**: 这是一个 HTTP 请求头，用于携带认证信息。在这种情况下，它的值是一个 Bearer 令牌。
> - ![image-20240809123822982](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240809123822982.png)



## 路由鉴权

> 业务背景：封装 `AuthRoute` 路由鉴权==高阶组件==，实现未登录拦截，并跳转到登录页面
> 实现思路：判断本地是否有token，如果有，就返回子组件，否则就重定向到登录Login
>
> 路由的权限控制：有些路由页面内的内容信息比较敏感，如果用户没有经过登录获取到有效Token，是没有权限跳转的，根据Token的有无控制当前路由是否可以跳转



**实现步骤**

1. 在 components 目录中，创建 `AuthRoute/index.js` 文件

2. 登录时，直接渲染相应页面组件

	未登录时，重定向到登录页面

	`components/AuthRoute/index.js`

```jsx
import { getToken } from '@/utils'
import { Navigate } from 'react-router-dom'

//{ children }为调用AuthRoute传过去的组件
const AuthRoute = ({ children }) => {
  const isToken = getToken()
  if (isToken) {
    return <>{children}</>
  } else {
    return <Navigate to="/login" replace />
  }
}

export default AuthRoute
```



3. 将需要鉴权的页面路由配置，替换为 AuthRoute 组件渲染

`src/router/index.js`

```jsx
import { createBrowserRouter } from 'react-router-dom'

import Login from '@/pages/Login'
import Layout from '@/pages/Layout'
import AuthRoute from '@/components/Auth'


const router = createBrowserRouter([
  {
    path: '/',
    element: <AuthRoute><Layout /></AuthRoute>,
  },
  {
    path: '/login',
    element: <Login />,
  },
])

export default router
```



## 样式全局初始化

> 可以帮助初始化padding margin为0

```bash
npm install normalize.css
```

```scss
//铺满整个页面
//root组件在 public/index.html下，需要
html,
body {
  margin: 0;
  height: 100%;
}

#root {
  height: 100%;
}
```



## 点击菜单跳转

1. 菜单栏 item的key值替换成路径

2. Menu组件添加` items={items}` 实现遍历
	 `onClick={menuClick}`绑定点击事件

3. ```js
	const navigate = useNavigate()
	const menuClick = (route) => {
	    navigate(route.key)
	  }
	```

```js
import { Outlet, useNavigate, useLocation } from 'react-router-dom'

const items = [
  {
    label: '首页',
    key: '/',
    icon: <HomeOutlined />,
  },
  {
    label: '文章管理',
    key: '/article',
    icon: <DiffOutlined />,
  },
  {
    label: '创建文章',
    key: '/publish',
    icon: <EditOutlined />,
  },
]


//获取当前路径,实现菜单栏高亮
const location = useLocation()
const selectedKey = location.pathname


const GeekLayout = () => {
  const navigate = useNavigate()
  const menuClick = (route) => {
    navigate(route.key)
  }
  return (
      <Menu
        mode="inline"
        theme="dark"
        selectedKeys={selectedKey}
        items={items}
        style={{ height: '100%', borderRight: 0 }}
        onClick={menuClick}
      /> 
  )
}
export default GeekLayout
```



## 退出登录   

1. 为气泡确认框添加确认回调事件 `pages/Layout/index.js`

	```jsx
	<Popconfirm title="是否确认退出？" okText="退出" cancelText="取消" onConfirm={loginOut}>
	```

2. 在`store/userStore.js` 中新增退出登录的reducer，导出action函数，在其中删除token

	```jsx
	clearUserInfo (state) {
	      state.token = ''
	      state.userInfo = {}
	      clearToken()
	    }
	```

3. 清除用户信息，返回登录页面

```js
// 退出登录
const loginOut = () => {
    dispatch(clearUserInfo())
    navigator('/login')
}
```



## 处理Token失效

> 业务背景：如果用户一段时间不做任何操作，到时之后应该清除所有过期用户信息跳回到登录
>
> 前端如何知道Token是否失效：通常在Token失效之后再去请求接口，后端会返回401状态码，前端可以监控这个状态做后续的操作
>
> Token失效了前端做什么？
>
> 1. 在axios拦截中监控401状态码
>
> 2. 清除失效Token，跳转登录



`utils/request.js`


```javascript
http.interceptors.response.use((response) => {
  // 2xx 范围内的状态码都会触发该函数。
  // 对响应数据做点什么
  return response.data
}, (error) => {
  
  //401状态码
  // 超出 2xx 范围的状态码都会触发该函数。
  // 对响应错误做点什么
  console.dir(error)
  if (error.response.status === 401) {
    clearToken()
    router.navigate('/login')
    //强制刷新，不显示报错页面，或者使用try catch模块
    window.location.reload()
  }

  return Promise.reject(error)
})
```



## Echarts封装

`component/BarChart.js`

https://echarts.apache.org/handbook/zh/get-started/

```bash
npm install echarts
```

```jsx
import { useRef, useEffect } from 'react'
import * as echarts from 'echarts'
//dom组件必须指定高和宽
const BarChart = ({ xData, sData, style = { width: '400px', height: '300px' } }) => {
  //使用钩子函数获取渲染图表的dom节点
  const chartRef = useRef(null)
  useEffect(() => {
    // 1. 获取渲染图表的dom节点 + 初始化生成实例对象
    const myChart = echarts.init(chartRef.current)
    // 2. 准备图表参数
    const option = {
      xAxis: {
        type: 'category',
        //将可变的数据变为prop参数
        data: xData
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          data: sData,
          type: 'bar'
        }
      ]
    }
    // 3. 渲染参数
    myChart.setOption(option)
  }, [sData, xData])
  return <div ref={chartRef} style={style}></div>
}

export { BarChart }
```



`Home/index.js`

```jsx
import { BarChart } from './BarChart'

const Home = () => {
  return (
    <div>
      <BarChart
        xData={['Vue', 'React', 'Angular']}
        sData={[2000, 5000, 1000]} />

      <BarChart
        xData={['Vue', 'React', 'Angular']}
        sData={[200, 500, 100]}
        style={{ width: '500px', height: '400px' }} />
    </div >
  )
}

export default Home
```



## API模块封装

**封装的好处**

> 接口在固定的模块内维护，方便后期查找维护

**封装逻辑**

> 接口逻辑写成函数, 请求参数当做形参传递

```jsx
// 用户相关的所有请求
import { request } from "@/utils"
// 1. 登录请求

export function loginAPI (formData) {
  return request({
    url: '/authorizations',
    method: 'POST',
    //请求参数
    data: formData
  })
}

// 2. 获取用户信息

export function getProfileAPI () {
  return request({
    url: '/user/profile',
    method: 'GET'
  })
}
```



`store/modules/user.js`

```js
//登陆获取token  异步封装方法
const fetchLogin = (loginForm) =>{
  return async (dispatch) =>{
    //user相关API封装前
    const res = await request.post('/authorizations',loginForm)
    //user相关API封装后
    const res = await loginAPI(loginForm)
    dispatch(setToken(res.data.token))
  }
}
```





## Questions

1. 后端在传给前端userinfo的时候，是怎么解析token的？前端是传给后端token了吗？还是自己从网页fetch？
2. request url？



# Day 8 & 9

## 基础文章发布

### 富文本编辑器

1. 安装富文本编辑器 

 `react-quill`

```bash
npm i react-quill@2.0.0-beta.2
```



2. 导入富文本编辑器组件以及样式文件

```jsx
import ReactQuill from 'react-quill'
import 'react-quill/dist/quill.snow.css'

const Publish = () => {
  return (
    // ...
    <Form
      labelCol={{ span: 4 }}
      wrapperCol={{ span: 16 }}
    >
      <Form.Item
        label="内容"
        name="content"
        rules={[{ required: true, message: '请输入文章内容' }]}
      >
        <ReactQuill
          className="publish-quill"
          theme="snow"
          placeholder="请输入文章内容"
        />
      </Form.Item>
    </Form>
  )
}
```



3. 调整富文本编辑器的样式

```css
.publish-quill {
  .ql-editor {
    min-height: 300px;
  }
}
```



### 下拉框数据渲染

1. 封装和文章相关的接口函数

	`apis/article.js`

```jsx
import { request } from "@/utils"

// 1. 获取频道列表
export function getChannelAPI () {
  return request({
    url: '/channels',
    method: 'GET'
  })
}

```



2. 使用useState初始化数据和修改数据的方法

​	`pages/Publish/index.js`

```jsx
// 频道列表
const [channels, setChannels] = useState([])

```



3. 在useEffect中调用接口并保存数据

```jsx
// 调用接口
useEffect(() => {
    async function fetchChannels() {
      const res = await getChannelAPI()
      setChannels(res.data.channels)
    }
    fetchChannels()
}, [])
```



4. 使用数据渲染对应模版

```jsx
return (
 <Form.Item
    label="频道"
    name="channel_id"
    rules={[{ required: true, message: '请选择文章频道' }]}
  >
    <Select placeholder="请选择文章频道" style={{ width: 200 }}>
      {channels.map(item => (
        //value属性用户选中之后会自动收集起来作为接口的提交字段
        <Option key={item.id} value={item.id}>
          {item.name}
        </Option>
      ))}
    </Select>
  </Form.Item>
)
```



### 提交表单

```jsx
const onFinish = async (formValue) => {
// 解构所需参数
const { channel_id, content, title } = formValue
// 2. 按照接口文档的格式处理收集到的表单数据
const params = {
    channel_id,
    content,
    title,
    type: 1,
    cover: {
    type: 1,
    images: []
    }
 }
  await createArticleAPI(param)
  message.success('发布文章成功')
}

//1. 使用Form组件收集表单数据
<Form onFinish={onFinish}>
```





### 实现基础上传

**实现步骤**

1. 为 Upload 组件添加 `action 属性`，配置封面图片上传==接口地址==
2. 为 Upload组件添加 `name属性`, 接口要求的字段名
3. 为 Upload 添加 `onChange 属性`，在事件中拿到当前图片数据，并==存储到React状态中==

```jsx
import { useState } from 'react'

const Publish = () => {
  // 上传图片
  const [imageList, setImageList] = useState([])
  const onUploadChange = (info) => {
      setImageList(info.fileList)
  

<Upload
        name="image"
 			  //文件框的外观样式
        listType="picture-card"
  			//控制显示上传列表
        showUploadList
  			//配置封面图片上传接口地址
        action={'http://geek.itheima.net/v1_0/upload'}
  			//在事件中拿到当前图片数据，井存储到React状态中
        onChange={onUploadChange}
        >
        <div style={{ marginTop: 8 }}>
          <PlusOutlined />
        </div>
</Upload>
```





### 上传多张图片

#### 切换上传图片上限

**实现步骤**

1. 点击单选框时拿到当前的类型value

```jsx
// 切换*图模式
  const [imageType, setImageType] = useState(0)
  const onTypeChange = (e) => {
    console.log('切换封面了', e.target.value)
    setImageType(e.target.value)
  }

<Form.Item name="type">
  <Radio.Group onChange={onTypeChange}>
    <Radio value={1}>单图</Radio>
    <Radio value={3}>三图</Radio>
    <Radio value={0}>无图</Radio>
  </Radio.Group>
</Form.Item>
```



2. 根据value控制上传组件的显示（大于零时才显示）

```jsx
 {  //在value大于0的时候才显示上传组件
    imageType > 0 &&
    <Upload></Upload>
    }
```



#### 处理图片列表格式为接口格式

> 接口格式  images：url
>
> map将一个数组映射成另一个新的数组

```jsx
cover: {
      type: imageType,
      images: imageList.map(item => item.response.data.url)
    }
```





## 文章列表页

### 自定义hook函数

1.在`hooks/useChannels.js`创建一个use打头的函数

```jsx
// 封装获取频道列表的逻辑
import { useState, useEffect } from 'react'
import { getChannelAPI } from '@/apis/article'
function useChannel () {
  // 1. 获取频道列表所有的逻辑
  // 获取频道列表
  const [channelList, setChannelList] = useState([])

  useEffect(() => {
    // 1. 封装函数 在函数体内调用接口
    const getChannelList = async () => {
      const res = await getChannelAPI()
      setChannelList(res.data.channels)
    }
    // 2. 调用函数
    getChannelList()
  }, [])
  // 2. 把组件中要用到的数据return出去
  return {
    channelList
  }
}
```

2.在函数中封装业务逻辑，并return出组件中要用到的状态数据

```jsx
// 2. 把组件中要用到的数据return出去
  return {
    channelList
  }
```



3.组件中导入函数执行并解构状态数据使用

```jsx
export { useChannel }
```





### 不同状态不同tag

使用render进行二次处理渲染

```jsx
// 定义状态枚举
  const status = {
    1: <Tag color='warning'>待审核</Tag>,
    2: <Tag color='success'>审核通过</Tag>,
  }

{
      title: '状态',
      dataIndex: 'status',
      // data - 后端返回的状态status 根据它做条件渲染
      // data === 1 => 待审核
      // data === 2 => 审核通过
     
      // 1.三元渲染
      render: data => data=== 1 ? <Tag color="Warning">待审核</Tag> : <Tag color="success">审核通过</Tag>
      // 2.枚举渲染
      render: data => status[data]
    },
```



### 删除功能

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240814032240570.png" alt="image-20240814032240570" style="zoom:50%;" />

**实现步骤**

1. 给删除文章按钮绑定点击事件 `onConfirm={() => delArticle(data)}`
2. 弹出确认窗口，询问用户是否确定删除文章  <Popconfirm></Popconfirm>
3. `delArticle`回调函数拿到参数调用删除接口，更新列表  async...await

**代码实现**

```jsx
// 删除回调
const delArticle = async (data) => {
    //下面这行代码可封装到API
    await http.delete(`/mp/articles/${data.id}`)
    // 更新列表
    setReqData({
      ...ReqData
    })
}

const columns = [
  // ...
  {
      title: '操作',
      render: data => {
        return (
          <Space size="middle">
            <Button type="primary" shape="circle" icon={<EditOutlined />} />
            <Popconfirm
              title="确认删除该条文章吗?"
               
               //关键行！！！ 
              onConfirm={() => delArticle(data)}
                
        
                
              okText="确认"
              cancelText="取消"
            >
              <Button
                type="primary"
                danger
                shape="circle"
                icon={<DeleteOutlined />}
              />
            </Popconfirm>
          </Space>
        )
      }
]
```





## 筛选功能实现

> 给请求列表接口传递不同的参数和后端要不同的数据

**实现步骤**
1. 准备请求参数

```js
 // 1. 准备参数
  const [reqData, setReqData] = useState({
    status: '',
    channel_id: '',
    begin_pubdate: '',
    end_pubdate: '',
    page: 1,
    per_page: 4
  })
  
  
 async function getList (reqData = {}) {
    const res = await getArticleListAPI(reqData)
    setList(res.data.results)
    setCount(res.data.total_count)
  }

  useEffect(() => {
    getList()
  }, [reqData])

```



2. 为表单添加`onFinish`属性监听表单提交事件，获取用户选择的表单数据，即请求参数

```jsx
 // 2. 获取筛选数据
  const onFinish = (formValue) => {
    console.log(formValue)
  }
```



3. 把表单数据放置到接口对应的字段中

```jsx
// 3.把表单收集到数据放到参数中(不可变的方式:setReqData,而不是用ReqData.channel_id直接更改value)
    setReqData({
      //...reqData 将 reqData 对象中的所有现有属性和对应的值展开，并复制到新的对象中
      ...reqData,
        //需要更新的值
      channel_id: formValue.channel_id,
      status: formValue.status,
      begin_pubdate: formValue.date[0].format('YYYY-MM-DD'),
      end_pubdate: formValue.date[1].format('YYYY-MM-DD')
    })
```



4. 重新调用文章列表接口渲染Table列表

​		依赖项[reqData] 发生改变时`useEffect`会重新被调用，再次getList()





### 分页功能实现

**实现步骤**

1. 为`Table`组件指定`pagination`属性来展示分页效果
2. 在分页切换事件中获取到筛选表单中选中的数据,即分页的页数`page`
3. 使用当前页数据==修改`ReqData`参数依赖==引起接口重新调用获取最新数据

**代码实现**

```jsx
const pageChange = (page) => {
    // 拿到当前页参数 修改params 引起接口更新
    setReqData({
      ...ReqData,
      page
    })
}

return (
   <Table rowKey="id" columns={columns} dataSource={article.list} pagination={{
      current: ReqData.page,
      pageSize: ReqData.per_page,
      onChange: pageChange,
      total: article.count
    }} />
)
```



## 编辑文章

### 编辑文章跳转

**实现步骤**

1. 获取当前文章id

2. 跳转到创建（编辑）文章的路由,通过id的参数拼接方法

```jsx
const navigate = useNavigate()

render:data=> {
  return(
    onClick={() => navagite(`/publish?id=${data.id}`)} />
  )
}

```



### 回填文章数据+封面信息

> 通过文章id获取到文章详情数据
>
> 调用Form组件实例方法 setFieldsValue 回显数据

```jsx
const Publish = ()=>{
  // 从url获取文章id，searchParams是一个对象，调用对象的get方法来获取id
  const [searchParams] = useSearchParams()
  const articleId = searchParams.get('id')
  //获取form实例
  const [form] = Form.useForm()
  useEffect(() => {
    async function getArticle () {
      const res = await http.get(`/mp/articles/${articleId}`)
      const { cover, ...formValue } = res.data
      // 设置表单数据
      // type: cover.type 解决之前formValue无法直接拿到type的问题，一定要注意数据结构 ，解决radio数据
      form.setFieldsValue({ ...formValue, type: cover.type })
      
      // 2. 回填封面图片
    setImageType(cover.type) // 之前绑定了只有在大于0的时候才会显示封面列表，1/3/0，set数据
    setImageList(cover.images.map(url => ({ url }))) // 获取图片url，映射成对象，封面list
    }
    
    //新增文章不需要回填
    if (articleId) {
      // 拉取数据回显
      getArticle()
    }
    
  }, [articleId, form])

  return (
     <Form form={form}/>
  )
}

```





### 适配不同状态下的文案

```jsx
<Card
  title={
    <Breadcrumb items={[
      { title: <Link to={'/'}>首页</Link> },
      { title: `${articleId ? '编辑文章' : '发布文章'}` },
    ]}
    />
  }
>

```



### 更新文章

> 和新增文章的逻辑大部分一致，需要做【参数适配】+ 调用【不同接口】

```jsx
// 发布文章
  const onFinish = async (formValue) => {
    const { channel_id, content, title } = formValue
    const formatUrl = (list) => {
        //回填图片的数据结构和上传新图的数据结构不同，url位置不同，需要做区分
      return list.map(item => {
        if (item.response) {
          return item.response.data.url
        } else {
          return item.url
        }
      })
    }
    const reqData = {
      channel_id,
      content,
      title,
      type: imageType,
      cover: {
        type: imageType,
        images: formatUrl(imageList)
      }
    }
    
    if (imageType !== imageList.length) return message.warning('图片类型和数量不一致')
    if (articleId) {
      // 编辑,接口要求有id，但是reqData数据结构中没有id，补参，构成一个完整的对象
      updateArticleAPI({...reqData,id:articleId})
    } else {
      // 新增
      createArticleAPI({...reqData,id:articleId})
    }
      
    message.success(`${articleId ? '编辑' : '发布'}文章成功`)
  }
```



## 项目打包

### 项目打包

```bash
npm run build
```



### 项目本地预览

**实现步骤**

1. 全局安装本地服务包 `npm i -g serve`  该包提供了serve命令，用来启动==本地服务器==
2. 在项目根目录中执行命令 `serve -s ./build`  在build目录中开启服务器
3. 在浏览器中访问：`http://localhost:3000/` 预览项目



## 项目优化

### 路由懒加载

**实现步骤**

1. 使用 **lazy 方法导入**路由组件
2. 使用内置的 **Suspense 组件渲染路由组件**

![image-20240815220704323](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240815220704323.png)

`router/index.js`

```jsx
import { createBrowserRouter } from 'react-router-dom'
import { lazy, Suspense } from 'react'
import Login from '@/pages/Login'
import Layout from '@/pages/Layout'

import AuthRoute from '@/components/Auth'

//lazy函数导入路由组件
const Publish = lazy(() => import('@/pages/Publish'))
const Article = lazy(() => import('@/pages/Article'))
const Home = lazy(() => import('@/pages/Home'))

//直接导入路由组件
import Publish  from '@/pages/Publish'
import Article  from '@/pages/Article'
import Home  from '@/pages/Home'


//suspense组件渲染路由组件，将路由组件包裹在内，fallback表示在渲染完成之前的显示
const router = createBrowserRouter([
  {
    path: '/',
    element: (
      <AuthRoute>
        <Layout />
      </AuthRoute>
    ),
    children: [
      {
        index: true,
        element: (
          <Suspense fallback={'加载中'}>
            <Home />
          </Suspense>
        )
      },
      {
        path: 'article',
        element: (
          <Suspense fallback={'加载中'}>
            <Article />
          </Suspense>
        )
      },
      {
        path: 'publish',
        element: (
          <Suspense fallback={'加载中'}>
            <Publish />
          </Suspense>
        )
      },
    ],
  },
  {
    path: '/login',
    element: <Login />,
  },
])

export default router
```



在**Web**端 **Network->JS**可以查看动态加载的js资源，即用哪个加载哪个



### 打包体积分析

**业务背景**

通过分析打包体积，才能知道项目中的哪部分内容体积过大，方便知道哪些包如何来优化



**使用步骤**

1. 安装分析打包体积的包：`npm i source-map-explorer`
2. 在 package.json 中的 scripts 标签中，添加分析打包体积的命令
3. 对项目打包：`npm run build`（如果已经打过包，可省略这一步）
4. 运行分析命令：`npm run analyze`
5. 通过浏览器打开的页面，分析图表中的包体积

**核心代码**：

```json
"scripts": {
  "analyze": "source-map-explorer 'build/static/js/*.js'",
}
```

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240815221853749.png" alt="image-20240815221853749" style="zoom:50%;" />



### 优化-配置CDN

**什么是CDN?**

CDN是一种内容分发网络服务，当用户请求网站内容时，由离用户最近的服务器将缓存的资源内容传递给用户。



**哪些资源可以放到CDN服务器?**

体积较大的非业务Js文件,比如react、react-dom

1. 体积较大，需要利用CDN文件在浏览器的缓存特性，加快加载时间

2. 非业务JS文件，不需要经常做变动，CDN不用频繁更新缓存

	

**项目中怎么做?**

1. 把需要做CDN缓存的文件排除在打包之外（react、react-dom)

	2. 以CDN的方式重新引l入资源(react、react-dom)



**分析说明**：通过 craco 来修改 webpack 配置，从而实现 CDN 优化
**核心代码**
`craco.config.js`

```javascript
// 添加自定义对于webpack的配置

const path = require('path')
const { whenProd, getPlugin, pluginByName } = require('@craco/craco')

module.exports = {
  // webpack 配置
  webpack: {
    // 配置别名
    alias: {
      // 约定：使用 @ 表示 src 文件所在路径
      '@': path.resolve(__dirname, 'src')
    },
    // 配置webpack
    // 配置CDN
    configure: (webpackConfig) => {
      let cdn = {
        js:[]
      }
      //只有当前是生产环境才做CDN配置
      whenProd(() => {
        // 把需要做CDN缓存的文件排除在打包之外
        // key: 不参与打包的包(由dependencies依赖项中的key决定)
        // value: cdn文件中 挂载于全局的变量名称 为了替换之前在开发环境下
        webpackConfig.externals = {
          react: 'React',
          'react-dom': 'ReactDOM'
        }
        // 配置现成的cdn资源地址
        // 实际开发的时候 用公司自己花钱买的cdn服务器
        cdn = {
          js: [
            'https://cdnjs.cloudflare.com/ajax/libs/react/18.1.0/umd/react.production.min.js',
 'https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.1.0/umd/react-dom.production.min.js',
          ]
        }
      })

      // 通过 htmlWebpackPlugin插件 在public/index.html注入cdn资源url
      const { isFound, match } = getPlugin(
        webpackConfig,
        pluginByName('HtmlWebpackPlugin')
      )

      if (isFound) {
        // 找到了HtmlWebpackPlugin的插件
        match.userOptions.files = cdn
      }

      return webpackConfig
    }
  }
}
```

`public/index.html`

```html
<body>
  <div id="root"></div>
  <!-- 加载第三发包的 CDN 链接 ，取出url -->
  <% htmlWebpackPlugin.options.files.js.forEach(cdnURL => { %>
    <script src="<%= cdnURL %>"></script>
  <% }) %>
</body>
```



# Day 10

## 渲染性能优化

### **useReducer**

**userState和useReducer的区别**

> `useReducer` 和 [`useState`](https://zh-hans.react.dev/reference/react/useState) 非常相似，但是它可以让你把状态更新逻辑从事件处理函数中移动到组件外部



**基础用法 — 实现步骤**

1.定义一个reducer函数（根据不同的action返回不同的新状态）

```js
import { useReducer } from 'react'

// 1. 定义reducer函数，根据不同的action返回不同的新状态
function reducer(state, action) {
  switch (action.type) {
    case 'INC':
      return state + 1
    case 'DEC':
      return state - 1
    case 'SET':
      return action.payload
    default:
      return state
  }
}
```



2.在组件中调用useReducer，并传入reducer函数和状态的初始值

3.事件发生时，通过dispatch函数分派一个action对象(通知reducer要返回哪个新状态并渲染Ul)

```jsx
function App() {
  // 2. 使用useReducer分派action
  const [state, dispatch] = useReducer(reducer, 0)
  return (
    <div>
      {//3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 
      <button onClick={() => dispatch({ type: 'DEC' })}>-</button>
      {state}
      <button onClick={() => dispatch({ type: 'INC' })}>+</button>
      <button onClick={() => dispatch({ type: 'SET', payload:100 })}>update</button>
    </div>
  )
}

export default App
```

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240817144356089.png" alt="image-20240817144356089" style="zoom:50%;" />



### useMemo

```jsx
const sum = useMemo(() => {
    return func(var1)
  }, [var1])
```



**基于==count==的变化计算斐波那契数列之和**

**背景：**默认机制——顶层组件发生重新渲染，这个组件树的子级组件都会被重新渲染

App组件中有两个状态变量，count和num，其中任意一个状态变量发生改变（包括不相关变量num），整个页面会重新渲染，在重新渲染时将会重新计算基于==count==变量的斐波那契数列之和

**作用：**常用于消耗非常大的计算，useMemo在每次重新渲染的时候能够缓存计算的结果,避免当我们修改==num==状态的时候，斐波那契求和函数也会被执行，防止内存泄漏

```jsx
// useMemo
// 作用：在组件渲染时缓存计算的结果

import { useState } from 'react'

function fib (n) {
  console.log('计算函数执行了')
  if (n < 3) return 1
  return fib(n - 2) + fib(n - 1)
}

function App() {
  const [count, setCount] = useState(0)
  
  // 计算斐波那契之和
  // 1. 不使用useMemo计算斐波那契之和
  const sumByCount = fib(count)
 
  // 2. 使用useMemo计算斐波那契之和
  const sum = useMemo(() => {
    return fib(count)
  }, [count])


  const [num, setNum] = useState(0)

  return (
    <>
      {sum}
      <button onClick={() => setCount(count + 1)}>+count:{count}</button>
      <button onClick={() => setNum(num + 1)}>+num:{num}</button>
    </>
  )
}

export default App
```



### React.memo

> **机制：**只有props发生变化时才重新渲染
> 下面的子组件通过==memo 进行包裹==之后，返回一个新的组件MemoSon, 只有传给MemoSon的==props参数==发生变化时才会重新渲染。可以观察到console中没有打印出“子组件被重新渲染了”这句话
>
> **比较memo和useMemo的区别:**
> memo 由props属性决定是否要变化缓存值
> useMemo 由传递过去的依赖项的变化决定是否要变化缓存值

```jsx
import React, { useState } from 'react'

const MemoSon = React.memo(function Son() {
  console.log('子组件被重新渲染了')
  return <div>this is span</div>
})

function App() {
  console.log('父组件重新渲染了')

  const [count, setCount] = useState(0)
  return (
    <>
      <MemoSon count={count} />
      <button onClick={() => setCount(count + 1)}>+{count}</button>
    </>
  )
}

export default App
```



**props的比较机制**

> 对于props的比较，进行的是‘浅比较’，底层使用 js的 `Object.is` 进行比较
>
> prop是简单类型  Object.is(3,3) => true 没有变化
>
> prop是引用类型（对象/数据）类型，只会对比俩次的引用是否相等，如果不相等就会重新渲染，React并不关心引用对象中的具体属性



说明：虽然俩次的list状态都是 `[1,2,3]` , 但是因为组件App俩次渲染生成了不同的对象引用list，所以传给MemoSon组件的props视为不同，子组件就会发生重新渲染

```jsx
import React, { useState } from 'react'

const MemoSon = React.memo(function Son() {
  console.log('子组件被重新渲染了')
  return <div>this is span</div>
})

function App() {
    
   const [count,setCount] = useState(0)
  //引用发生变化，prop视为不同
  const list = [1, 2, 3]
  
  //使用useMemo保证引用稳定,传递空依赖表示只渲染一次，list引用稳定不变
   const list = useMemo(()=>{
       return [1, 2, 3]
   },[]) 
  
  return (
    <>
      <MemoSon list={list} />
      <button onClick={() => setCount(count+1)}>
      </button>
    </>
  )
}

export default App
```



### useCallback

> useCallback缓存之后的函数可以在组件渲染时保持引用稳定，也就是返回同一个引用

```jsx
// useCallBack

import { memo, useCallback, useState } from 'react'

const MemoSon = memo(function Son() {
  console.log('Son组件渲染了')
  return <div>this is son</div>
})

function App() {
  const [, forceUpate] = useState()
  console.log('父组件重新渲染了')
  const onGetSonMessage = useCallback((message) => {
    console.log(message)
  }, [])

  return (
    <div>
      <MemoSon onGetSonMessage={onGetSonMessage} />
      <button onClick={() => forceUpate(Math.random())}>update</button>
    </div>
  )
}

export default App
```



## Ref 子组件暴露给父组件

### forwardRef

作用：允许组件使用ref将一个DOM节点暴露给父组件

应用场景：1.聚焦文本输入框   2.播放和暂停视频

> 默认情况下，每个组件的 DOM 节点都是私有的。然而，有时候将 DOM 节点公开给父组件是很有用的，比如允许对它进行聚焦。将组件定义包装在 `forwardRef()` 中便可以公开 DOM 节点
>
> `forwardRef` 返回一个可以在 JSX 中渲染的 React 组件。与作为纯函数定义的 React 组件不同，`forwardRef` 返回的组件还能够接收 `ref` 属性



点击edit button实现文本框聚焦：

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240824200200101.png" alt="image-20240824200200101" style="zoom:50%;" />

```jsx
import { forwardRef, useRef } from 'react'

const MyInput = forwardRef(function Input(props, ref) {
  return <input {...props} type="text" ref={ref} />
}, [])

function App() {
  const SonRef = useRef(null)

  const focusHandle = () => {
    console.log(SonRef.current.focus())
  }

  return (
    <div>
      <MyInput label="Enter your name:" ref={SonRef} />
      <button onClick={focusHandle}>focus</button>
    </div>
  )
}

export default App
```



### useImperativeHandle

作用：通过ref调用子组件的方法，例如调用子组件内部的focus方法实现聚焦

```jsx
import { forwardRef, useImperativeHandle, useRef } from 'react'

const MyInput = forwardRef(function Input(props, ref) {
  // 实现内部的聚焦逻辑
  const inputRef = useRef(null)
  const focus = () => inputRef.current.focus()

  // 暴露子组件内部的聚焦方法
  useImperativeHandle(ref, () => {
    return {
      focus,
    }
  })

  return <input {...props} ref={inputRef} type="text" />
})

function App() {
  const ref = useRef(null)

  const focusHandle = () => ref.current.focus()

  return (
    <div>
      <MyInput ref={ref} />
      <button onClick={focusHandle}>focus</button>
    </div>
  )
}

export default App
```



## 类组件

通过JS中的类来组织组件中的代码

> 1.通过类属性state定义状态数据
>
> 2.通过setState方法来修改状态数据
>
> 3.通过render来写UI模版 (JSX语法一致)

不建议使用



## Zustand

[Zustand Documentation](https://docs.pmnd.rs/zustand/getting-started/introduction)



<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240824213304802.png" alt="image-20240824213304802" style="zoom:50%;" />

### 基础用法

1. `store/index.js`  **创建store**

```javascript
import { create } from 'zustand'

const useStore = create((set) => {
  return {
	//状态数据
    count: 0,
     //修改状态数据的方法
    inc: () => {
        // 1. 要求set函数返回一个对象，对象内部编写状态数据和方法
        // 2. set是用来修改数据的专门方法必须调用它来修改数据
        // 语法1：参数是函数 需要用到老数据的场景
        // 语法2：参数直接是一个对象 set({count：100 })
      set( (state) => ({ count: state.count + 1 }))
    }.
      //异步逻辑
      channelList: [],
      fetchChannelList: async () => {
      const res = await fetch(URL)
      const jsonData = await res.json()
      set({channelList: jsonData.data.channels})
  }
})

export default useStore
```

2. `app.js`  **绑定组件消费store**

```jsx
import useStore from './store/useCounterStore.js'

function App() {
  //1.同步
  const { count, inc } = useStore()
  return <button onClick={inc}>{count}</button>
    
  //2.异步
  const { channelList, fetchChannelList } = useChannelStore()
 
  useEffect(() => {
    fetchChannelList()
  }, [fetchChannelList])

  return (
    <ul>
      {channelList.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  )
}
}

export default App
```



### 切片模式

场景：当我们单个store比较大的时候，可以采用一种`切片模式`进行模块拆分再组合

<img src="https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240824220206927.png" alt="image-20240824220206927" style="zoom: 33%;" />

**拆分并组合切片**

```javascript
import { create } from 'zustand'

// 创建counter相关切片
const createCounterStore = (set) => {
  return {
    count: 0,
    setCount: () => {
      set(state => ({ count: state.count + 1 }))
    }
  }
}

// 创建channel相关切片
const createChannelStore = (set) => {
  return {
    channelList: [],
    fetchGetList: async () => {
      const res = await fetch(URL)
      const jsonData = await res.json()
      set({ channelList: jsonData.data.channels })
    }
  }
}

// 组合切片
const useStore = create((...a) => ({
  ...createCounterStore(...a),
  ...createChannelStore(...a)
}))
```



> 1. `createCounterStore` 和 `createChannelStore` 是两个函数，它们各自返回一个状态对象。
>
> 2. `...` 是“展开运算符”（spread operator），用于将对象的属性展开到当前对象中。这样，可以将 `createCounterStore` 和 `createChannelStore` 返回的对象属性合并到一个单一的对象中。
>
> 3. `(...a)` 
>
> 	这是一个“rest 参数”语法，表示将所有传入的参数收集到一个数组 `a` 中。这意味着 `a` 是一个包含了所有传给这个匿名函数的参数的数组
>
> 	调用 `createCounterStore` 和 `createChannelStore` 时，将 `a` 中的参数展开传递给这些函数。



**组件使用**

```jsx
function App() {
  const {count, inc, channelList, fetchChannelList } = useStore()
  return (
    <>
      <button onClick={inc}>{count}</button>
      <ul>
        {channelList.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </>
  )
}

export default App
```



### 对接DevTools

> 简单的调试我们可以安装一个 名称为 simple-zustand-devtools 的调试工具

**安装调试包**

```bash
npm i simple-zustand-devtools -D
```

**配置调试工具**

```javascript
import create from 'zustand'

// 导入核心方法
import { mountStoreDevtool } from 'simple-zustand-devtools'

// 省略部分代码...


// 开发环境开启调试
if (process.env.NODE_ENV === 'development') {
  mountStoreDevtool('channelStore', useChannelStore)
}


export default useChannelStore
```

打开 React调试工具

![image-20240824224708690](https://2024-2.oss-cn-beijing.aliyuncs.com/typora/image-20240824224708690.png)



# Day 11

## 使用Vite创建项目

> Vite是一个框架无关的前端工具链工具，可以帮助我们快速创建一个 `react+ts` 的工程化环境出来，我们可以基于它做语法学习

[Vite](https://cn.vitejs.dev/)

> 指定项目名称为react-ts-pro

```bash
npm create vite@latest react-ts-pro -- --template react-ts
```

**安装依赖运行项目**

```bash
# 安装依赖
npm i 

# 运行项目
npm run dev
```



## useState

###  自动推断参数类型

> 简单场景下，可以使用TS的自动推断机制，不用特殊编写类型注解，运行良好

```typescript
const [val, toggle] = React.useState(false)

// `val` 会被自动推断为布尔类型
// `toggle` 方法调用时只能传入布尔类型
```



### 指定参数类型

> 复杂数据类型，useState支持通过`泛型参数`，可以传入自定义参数类型，指定==初始参数类型==以及==setter函数的入参类型==

#### 有具体默认值

```typescript
type User = {
  name: string
  age: number
}
const [user, setUser] = React.useState<User>({
  name: 'jack',
  age: 18
})
// 执行setUser
setUser(newUser)
// 这里newUser对象只能是User类型
```



#### 没有具体默认值

> 实际开发时，有些时候useState的初始值可能为null或者undefined，按照泛型的写法是不能通过类型校验的，此时可以通过完整的==类型联合null==或者undefined类型即可

```typescript
// react + ts
import { useState } from 'react'

type User = {
  name: String
  age: Number
}

function App() {
const [user, setUser] = React.useState<User>(null)
// 上面会类型错误，因为null并不能分配给User类型

const [user, setUser] = React.useState<User | null>(null)
// 上面既可以在初始值设置为null，同时满足setter函数setUser的参数可以是具体的User类型

const changeUser = () => {
    setUser(null)
    setUser({
      name: 'jack',
      age: 18,
    })
  }
  // 为了类型安全  可选链做类型守卫
  // 只有user不为null（不为空值）的时候才进行点运算
  return <>this is app {user?.age}</>
}
export default App
```



## useRef

> 在TypeScript的环境下，`useRef` 函数返回一个`只读` 或者 `可变` 的引用，只读的场景常见于获取真实dom，可变的场景，常见于缓存一些数据，不跟随组件渲染，下面分俩种情况说明

### 获取dom

> 获取DOM时，通过泛型参数指定具体的DOM元素类型即可

```tsx
function Foo() {
  // 尽可能提供一个具体的dom type, 可以帮助我们在用dom属性时有更明确的提示
  // divRef的类型为 RefObject<HTMLDivElement>
  const domtRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
   //类型守卫 防止出现空值点运算错误
    domRef.current?.focus()
  },[])

  return <div ref={domRef}>etc</div>
}
```



### 稳定引用存储器

> 当做为可变存储容器使用的时候，可以通过`泛型参数`指定容器存入的数据类型, 在还为存入实际内容时通常把null作为初始值，所以依旧可以通过联合类型做指定

```tsx
function App(){
   // 稳定引用的存储器（定时器管理）
  const timerRef = useRef<number | undefined>(undefined)
  
  useEffect(()=>{
    timerRef.current = window.setInterval(()=>{
      console.log('测试')
    },1000)
    
    //在组件卸载时触发，用于清理副作用中的定时器。
    return ()=>clearInterval(timerRef.current)
  },[])
  return <div> this is app</div>
}
```



## 为Props添加类型

> props作为React组件的参数入口，添加了类型之后可以限制参数输入以及在使用props有良好的类型提示, 本质是给函数的参数做类型注解，可以使用type对象类型或者interface接口来做注解

```tsx
// 1.使用interface接口
interface Props {
  className: string
}

// 2.使用自定义类型Type
type Props =  {
  className: string
}

export const Button = (props:Props)=>{
  const { className } = props
  return <button className={ className }>Test</button>
}

function App() {
  return (
    <>
      <Button className="test" />
    </>
  )
}

```



### 为Props的chidren属性添加类型

> children属性和props中其他的属性不同，它是React系统中内置的，其它属性我们可以自由控制其类型，children属性的类型最好由React内置的类型提供，兼容多种类型


```tsx
type Props = {
  children: React.ReactNode
}

export const Button = (props: Props)=>{
   const { children } = props
   return <button> { children } </button>
}
```

> 说明：React.ReactNode是一个React内置的联合类型，包括 `React.ReactElement` 、`string`、`number` `React.ReactFragment` 、`React.ReactPortal` 、`boolean`、 `null` 、`undefined`





### 为事件prop添加类型

> 组件经常执行类型为函数的prop实现子传父，这类prop重点在于函数参数类型的注解

```tsx
// props + ts
type Props = {
    //？表示可选属性，如果没有的话为必选，漏了会报错
  onGetMsg?: (msg: string) => void
}

function Son(props: Props) {
  const { onGetMsg } = props
  //1.在组件内部调用时需要遵守类型的约束，参数传递需要满足要求
  const clickHandler = () => {
    onGetMsg?.('this is msg')
  }
  return <button onClick={clickHandler}>sendMsg</button>
}

function App() {
  const getMsgHandler = (msg: string) => {
    console.log(msg)
  }
  return (
    <>
   	  //绑定内联函数可以直接推断出参数类型
      <Son onGetMsg={(msg) => console.log(msg)} />
      //否则需要单独注解匹配的参数类型
      <Son onGetMsg={getMsgHandler} />
    </>
  )
}

export default App
```



#### 为事件handle添加类型

> 为事件回调添加类型约束需要使用React内置的泛型函数来做，比如最常见的鼠标点击事件和表单输入事件：

```tsx
function App(){
  const changeHandler: React.ChangeEventHandler<HTMLInputElement> = (e)=>{
    console.log(e.target.value)
  }
  
  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = (e)=>{
    console.log(e.target)
  }

  return (
    <>
      <input type="text" onChange={ changeHandler }/>
      <button onClick={ clickHandler }> click me!</button>
    </>
  )
}
```

